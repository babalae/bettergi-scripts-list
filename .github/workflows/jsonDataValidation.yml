name: JSON Data Validation

on:
  pull_request_target:
    types: [opened, synchronize, reopened, edited]
    branches:
      - main
    paths:
      - 'repo/pathing/**/*.json'
  workflow_dispatch:
    inputs:
      path:
        description: 'è¦éªŒè¯çš„è·¯å¾„'
        required: true
        default: 'repo/pathing'
        type: string
      auto_fix:
        description: 'æ˜¯å¦è‡ªåŠ¨ä¿®å¤é—®é¢˜'
        required: false
        default: true
        type: boolean
      pr_number:
        description: 'å…³è”çš„ PR å·'
        required: false
        type: string

jobs:
  validate-json:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Set environment variables based on trigger type
        id: set_env
        run: |
          # æ ¹æ®è§¦å‘ç±»å‹è®¾ç½®ç¯å¢ƒå˜é‡
          if [ "${{ github.event_name }}" = "pull_request_target" ]; then
            echo "è§¦å‘ç±»å‹: PRè§¦å‘"
            echo "trigger_type=pr" >> $GITHUB_OUTPUT
            echo "validate_path=pr_files" >> $GITHUB_OUTPUT
            echo "auto_fix=true" >> $GITHUB_OUTPUT
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "head_ref=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
            echo "head_repo=${{ github.event.pull_request.head.repo.full_name }}" >> $GITHUB_OUTPUT
            echo "base_ref=${{ github.event.pull_request.base.ref }}" >> $GITHUB_OUTPUT
            echo "base_sha=${{ github.event.pull_request.base.sha }}" >> $GITHUB_OUTPUT
          else
            echo "è§¦å‘ç±»å‹: æ‰‹åŠ¨è§¦å‘"
            echo "trigger_type=manual" >> $GITHUB_OUTPUT
            echo "validate_path=${{ github.event.inputs.path }}" >> $GITHUB_OUTPUT
            echo "auto_fix=${{ github.event.inputs.auto_fix }}" >> $GITHUB_OUTPUT
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
            echo "head_ref=" >> $GITHUB_OUTPUT
            echo "head_repo=" >> $GITHUB_OUTPUT
            echo "base_ref=main" >> $GITHUB_OUTPUT
            echo "base_sha=" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install packaging semver
          pip install chardet

      - name: Debug file structure
        run: |
          echo "è§¦å‘ç±»å‹: ${{ steps.set_env.outputs.trigger_type }}"
          echo "éªŒè¯è·¯å¾„: ${{ steps.set_env.outputs.validate_path }}"
          echo "è‡ªåŠ¨ä¿®å¤: ${{ steps.set_env.outputs.auto_fix }}"
          echo "PRå·: ${{ steps.set_env.outputs.pr_number }}"
          echo "Current directory: $(pwd)"
          echo "List files in root:"
          ls -la
          echo "List files in build directory (if exists):"
          if [ -d "build" ]; then
            ls -la build/
          else
            echo "build directory does not exist"
            mkdir -p build
          fi

      - name: Setup Git and repositories
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
          # è®¾ç½®Gitå¤„ç†ä¸­æ–‡ç­‰ç‰¹æ®Šå­—ç¬¦
          git config --global core.quotepath false
          
          # ç¡®ä¿è¿œç¨‹ä»“åº“è®¾ç½®æ­£ç¡®
          echo "å½“å‰è¿œç¨‹ä»“åº“é…ç½®:"
          git remote -v
          
          # è®¾ç½®å˜é‡
          MAIN_REPO="${{ github.repository }}"
          PR_REPO="${{ github.event.pull_request.head.repo.full_name || github.repository }}"
          
          # è®¾ç½®ä¸Šæ¸¸ä»“åº“(upstream)æŒ‡å‘ä¸»ä»“åº“
          UPSTREAM_REPO="https://github.com/${MAIN_REPO}.git"
          echo "è®¾ç½®upstreamæŒ‡å‘ä¸»ä»“åº“: $UPSTREAM_REPO"
          git remote remove upstream 2>/dev/null || true
          git remote add upstream $UPSTREAM_REPO
          
          # ç¡®ä¿originæŒ‡å‘PRçš„forkä»“åº“
          if [ "$PR_REPO" != "$MAIN_REPO" ] && [ "${{ steps.set_env.outputs.trigger_type }}" = "pr" ]; then
            ORIGIN_REPO="https://github.com/${PR_REPO}.git"
            echo "PRæ¥è‡ªforkä»“åº“ï¼Œè®¾ç½®originæŒ‡å‘: $ORIGIN_REPO"
          else
            ORIGIN_REPO=$UPSTREAM_REPO
            echo "PRæ¥è‡ªåŒä¸€ä»“åº“æˆ–éPRè§¦å‘ï¼Œoriginä¸upstreamç›¸åŒ: $ORIGIN_REPO"
          fi
          
          git remote set-url origin $ORIGIN_REPO 2>/dev/null || git remote add origin $ORIGIN_REPO
          
          # è·å–æœ€æ–°çš„ä¸»ä»“åº“å’Œåˆ†æ”¯
          echo "è·å–è¿œç¨‹åˆ†æ”¯ä¿¡æ¯"
          git fetch upstream
          git fetch origin
          
          # æ˜¾ç¤ºè¿œç¨‹ä»“åº“é…ç½®
          echo "æ›´æ–°åçš„è¿œç¨‹ä»“åº“é…ç½®:"
          git remote -v
          
          # æ£€æŸ¥æ˜¯å¦å¤„äºPRç¯å¢ƒå¹¶åˆ‡æ¢åˆ°æ­£ç¡®çš„åˆ†æ”¯
          if [ "${{ steps.set_env.outputs.trigger_type }}" = "pr" ] && [ -n "${{ steps.set_env.outputs.head_ref }}" ]; then
            echo "æ£€æµ‹åˆ°PRï¼Œåˆ‡æ¢åˆ°PRåˆ†æ”¯: ${{ steps.set_env.outputs.head_ref }}"
            if [ "$PR_REPO" != "$MAIN_REPO" ]; then
              # forkä»“åº“çš„PRï¼Œéœ€è¦å…ˆåˆ›å»ºæœ¬åœ°åˆ†æ”¯è¿½è¸ªforkçš„è¿œç¨‹åˆ†æ”¯
              git checkout -b "${{ steps.set_env.outputs.head_ref }}" --track "origin/${{ steps.set_env.outputs.head_ref }}" || \
              git checkout -b "${{ steps.set_env.outputs.head_ref }}" --no-track && \
              git push --set-upstream origin "${{ steps.set_env.outputs.head_ref }}"
            else
              # åŒä¸€ä»“åº“çš„PR
              git checkout "${{ steps.set_env.outputs.head_ref }}" || git checkout -b "${{ steps.set_env.outputs.head_ref }}"
            fi
          elif [ -n "${{ github.ref_name }}" ]; then
            echo "åˆ‡æ¢åˆ°åˆ†æ”¯: ${{ github.ref_name }}"
            if [[ "${{ github.ref_name }}" == "main" ]]; then
              # mainåˆ†æ”¯éœ€è¦æ˜ç¡®æŒ‡å®š
              git checkout upstream/main -b main
            else
              git checkout "${{ github.ref_name }}" || git checkout -b "${{ github.ref_name }}"
            fi
          else
            echo "åˆ›å»ºä¸´æ—¶åˆ†æ”¯"
            git checkout -b temp-validation-branch
          fi

      - name: Prepare validation script
        run: |
          # æ£€æŸ¥buildç›®å½•å’Œvalidate.pyæ–‡ä»¶æ˜¯å¦å­˜åœ¨
          mkdir -p build
          if [ ! -f "build/validate.py" ]; then
            echo "build/validate.pyä¸å­˜åœ¨ï¼Œè·³è¿‡è·å–æ­¥éª¤"
          else
            echo "build/validate.pyå·²å­˜åœ¨ï¼Œæ£€æŸ¥æ–‡ä»¶å¤´éƒ¨"
            head -n 5 build/validate.py
          fi

      - name: Get PR information for workflow_dispatch
        if: ${{ steps.set_env.outputs.trigger_type == 'manual' && steps.set_env.outputs.pr_number != '' }}
        id: pr_info
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: parseInt(${{ steps.set_env.outputs.pr_number }})
              });
              
              core.setOutput('head_sha', pr.data.head.sha);
              core.setOutput('head_ref', pr.data.head.ref);
              core.setOutput('head_repo', pr.data.head.repo.full_name);
              core.setOutput('found', 'true');
              
              console.log(`æ‰¾åˆ° PR #${{ steps.set_env.outputs.pr_number }}`);
              console.log(`Head SHA: ${pr.data.head.sha}`);
              console.log(`Head Ref: ${pr.data.head.ref}`);
              console.log(`Head Repo: ${pr.data.head.repo.full_name}`);
              
              // å¦‚æœæ‰¾åˆ°PRï¼Œåˆ‡æ¢åˆ°PRåˆ†æ”¯
              const exec = require('child_process').execSync;
              if (pr.data.head.ref) {
                console.log(`åˆ‡æ¢åˆ°PRåˆ†æ”¯: ${pr.data.head.ref}`);
                exec(`git checkout ${pr.data.head.ref} || git checkout -b ${pr.data.head.ref}`);
              }
            } catch (error) {
              console.log(`è·å– PR #${{ steps.set_env.outputs.pr_number }} ä¿¡æ¯å¤±è´¥: ${error.message}`);
              core.setOutput('found', 'false');
            }

      - name: Get changed files for PR trigger
        id: changed_files
        if: ${{ steps.set_env.outputs.trigger_type == 'pr' }}
        run: |
          # è¾“å‡ºåˆ†æ”¯ä¿¡æ¯ä¾¿äºè°ƒè¯•
          echo "å½“å‰åˆ†æ”¯: $(git branch --show-current)"
          echo "HEADæŒ‡å‘: $(git rev-parse HEAD)"
          echo "PRåŸºç¡€åˆ†æ”¯: ${{ steps.set_env.outputs.base_ref }}"
          
          # ç¡®ä¿æœ‰upstream/mainåˆ†æ”¯
          git fetch upstream main
          echo "Upstream/main SHA: $(git rev-parse upstream/main)"
          
          # åˆ›å»ºä¸´æ—¶å˜é‡æ¥å­˜å‚¨ä¿®æ”¹çš„æ–‡ä»¶åˆ—è¡¨
          CHANGED_FILES=""
          
          # æ–¹æ³•1ï¼šå°è¯•ä½¿ç”¨git diffæ£€æµ‹å˜åŒ–
          echo "æ£€æµ‹æ–¹æ³•1: ä½¿ç”¨git diffæ£€æµ‹"
          FILES_METHOD_1=$(git diff --name-only upstream/main HEAD | grep -E '^repo/pathing/.*\.json$' || true)
          if [ -n "$FILES_METHOD_1" ]; then
            echo "æ–¹æ³•1æ‰¾åˆ°çš„JSONæ–‡ä»¶:"
            echo "$FILES_METHOD_1"
            CHANGED_FILES="$FILES_METHOD_1"
          else
            echo "æ–¹æ³•1æœªæ‰¾åˆ°ä¿®æ”¹çš„JSONæ–‡ä»¶"
          fi
          
          # æ–¹æ³•2ï¼šå¦‚æœæ–¹æ³•1å¤±è´¥ï¼Œå°è¯•ç›´æ¥æŸ¥è¯¢PR APIè·å–ä¿®æ”¹çš„æ–‡ä»¶
          if [ -z "$CHANGED_FILES" ] && [ -n "${{ steps.set_env.outputs.pr_number }}" ]; then
            echo "æ£€æµ‹æ–¹æ³•2: ä½¿ç”¨GitHub APIæ£€æµ‹"
            PR_FILES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        "https://api.github.com/repos/${{ github.repository }}/pulls/${{ steps.set_env.outputs.pr_number }}/files" | \
                      jq -r '.[] | select(.filename | test("^repo/pathing/.*\\.json$")) | .filename')
            
            if [ -n "$PR_FILES" ]; then
              echo "æ–¹æ³•2æ‰¾åˆ°çš„JSONæ–‡ä»¶:"
              echo "$PR_FILES"
              CHANGED_FILES="$PR_FILES"
            else
              echo "æ–¹æ³•2æœªæ‰¾åˆ°ä¿®æ”¹çš„JSONæ–‡ä»¶"
            fi
          fi
          
          # æ–¹æ³•3ï¼šå¦‚æœå‰ä¸¤ç§æ–¹æ³•éƒ½å¤±è´¥ï¼Œåˆ—å‡ºæ‰€æœ‰repo/pathingä¸­çš„JSONæ–‡ä»¶ï¼Œä½†é™åˆ¶åœ¨æœ€è¿‘ä¿®æ”¹çš„
          if [ -z "$CHANGED_FILES" ]; then
            echo "æ£€æµ‹æ–¹æ³•3: åˆ—å‡ºæœ€è¿‘ä¿®æ”¹çš„JSONæ–‡ä»¶"
            # åˆ—å‡ºè¿‡å»5æ¬¡æäº¤ä¸­ä¿®æ”¹çš„JSONæ–‡ä»¶
            RECENT_FILES=$(git log -n 5 --name-only --pretty=format: | grep -E '^repo/pathing/.*\.json$' | sort -u || true)
            
            if [ -n "$RECENT_FILES" ]; then
              echo "æœ€è¿‘ä¿®æ”¹çš„JSONæ–‡ä»¶:"
              echo "$RECENT_FILES"
              CHANGED_FILES="$RECENT_FILES"
              echo "âš ï¸ è­¦å‘Š: ä½¿ç”¨æœ€è¿‘ä¿®æ”¹çš„æ–‡ä»¶ä½œä¸ºå›é€€æ–¹æ¡ˆ"
            else
              echo "æ–¹æ³•3æœªæ‰¾åˆ°æœ€è¿‘ä¿®æ”¹çš„JSONæ–‡ä»¶"
            fi
          fi
          
          # æœ€åå›é€€æ–¹æ¡ˆï¼šç›´æ¥æŒ‡å®šéªŒè¯ç›®å½•
          if [ -z "$CHANGED_FILES" ]; then
            echo "âš ï¸ è­¦å‘Š: æ‰€æœ‰æ–¹æ³•å‡æœªæ£€æµ‹åˆ°ä¿®æ”¹çš„JSONæ–‡ä»¶ï¼Œå°†éªŒè¯æ•´ä¸ªrepo/pathingç›®å½•"
            CHANGED_FILES="repo/pathing"
          fi
          
          # è¾“å‡ºç»“æœ
          echo "æœ€ç»ˆæ‰¾åˆ°çš„ä¿®æ”¹æ–‡ä»¶:"
          echo "$CHANGED_FILES"
          # ä½¿ç”¨base64ç¼–ç ä¿å­˜æ–‡ä»¶åˆ—è¡¨ï¼Œé¿å…ç‰¹æ®Šå­—ç¬¦é—®é¢˜
          echo "changed_files=$(echo "$CHANGED_FILES" | base64 -w 0)" >> $GITHUB_OUTPUT

      - name: Run validation for PR trigger
        if: ${{ steps.set_env.outputs.trigger_type == 'pr' }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PR_NUMBER: ${{ steps.set_env.outputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_REF: ${{ steps.set_env.outputs.head_ref }}
          PR_REPO: ${{ steps.set_env.outputs.head_repo || github.repository }}
          CHANGED_FILES_B64: ${{ steps.changed_files.outputs.changed_files }}
        run: |
          set -e
          # ä½¿ç”¨base64è§£ç æ–‡ä»¶åˆ—è¡¨
          CHANGED_FILES=$(echo "$CHANGED_FILES_B64" | base64 --decode)
          
          echo "è¿›è¡Œåœ°å›¾è¿½è¸ªç›®å½•ç»“æ„æ ¡éªŒ"
          
          # åœ°å›¾è¿½è¸ªç›®å½•ç»“æ„æ ¡éªŒ
          echo "ğŸ” å¼€å§‹åœ°å›¾è¿½è¸ªç›®å½•ç»“æ„æ ¡éªŒ..."
          : > validation_output.log
          set +e
          python build/validate.py "repo/pathing" --fix 2>&1 | tee -a validation_output.log
          PY_EXIT=$?
          set -e
          
          # æ£€æŸ¥ç›®å½•ç»“æ„æ ¡éªŒç»“æœ
          if [ $PY_EXIT -ne 0 ]; then
            echo "âŒ pathingç›®å½•ç»“æ„æ ¡éªŒå¤±è´¥"
            VALIDATION_FAILED=true
          elif grep -E "âŒ.*ç›®å½•ç»“æ„é”™è¯¯" -q validation_output.log; then
            echo "âŒ æ£€æµ‹åˆ°åœ°å›¾è¿½è¸ªç›®å½•ç»“æ„é”™è¯¯"
            VALIDATION_FAILED=true
          else
            echo "âœ… åœ°å›¾è¿½è¸ªç›®å½•ç»“æ„æ ¡éªŒé€šè¿‡"
            VALIDATION_FAILED=false
          fi
          
          # å¦‚æœç›®å½•ç»“æ„æ ¡éªŒå¤±è´¥ï¼Œç›´æ¥é€€å‡º
          if [ "$VALIDATION_FAILED" = true ]; then
            echo "æ£€æµ‹åˆ°åœ°å›¾è¿½è¸ªç›®å½•ç»“æ„é”™è¯¯ï¼Œç”Ÿæˆæ ¡éªŒè¯´æ˜å¹¶æ ‡è®°å¤±è´¥"
            {
              echo "### âŒ åœ°å›¾è¿½è¸ªç›®å½•ç»“æ„æ ¡éªŒå¤±è´¥"
              echo "è¯·å‰å¾€ Actions æŸ¥çœ‹æŠ¥é”™è¯¦æƒ…ï¼ˆè¿è¡Œæ—¥å¿—ï¼‰ã€‚"
            } > validation_notes.md
            exit 1
          fi
          
          # ç›®å½•ç»“æ„æ ¡éªŒé€šè¿‡åï¼Œç»§ç»­éªŒè¯ä¿®æ”¹çš„JSONæ–‡ä»¶
          echo "PR è§¦å‘æ¨¡å¼ï¼ŒéªŒè¯ä¿®æ”¹çš„ JSON æ–‡ä»¶"
          if [ -z "$CHANGED_FILES" ]; then
            echo "æ²¡æœ‰æ‰¾åˆ°ä¿®æ”¹çš„ JSON æ–‡ä»¶ï¼Œè·³è¿‡JSONå†…å®¹éªŒè¯"
            exit 0
          fi
          
          # æ£€æŸ¥Pythonè§£é‡Šå™¨ç¼–ç è®¾ç½®
          echo "Pythonç¼–ç è®¾ç½®:"
          python -c "import sys; print(sys.getdefaultencoding())"
          
          # é‡æ–°åˆå§‹åŒ–æ—¥å¿—æ–‡ä»¶ç”¨äºJSONå†…å®¹æ ¡éªŒ
          : > validation_output.log
          VALIDATION_FAILED=false

          # å§‹ç»ˆåªéªŒè¯ä¿®æ”¹çš„æ–‡ä»¶ï¼Œä¸å†éªŒè¯æ•´ä¸ªç›®å½•
          # åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶æ¥å­˜å‚¨æ–‡ä»¶åˆ—è¡¨
          echo "$CHANGED_FILES" > temp_file_list.txt
          # å•ç‹¬éªŒè¯æ¯ä¸ªä¿®æ”¹çš„æ–‡ä»¶ï¼Œä½¿ç”¨whileè¯»å–é¿å…æ–‡ä»¶åä¸­çš„ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦é—®é¢˜
          while IFS= read -r file; do
            echo "éªŒè¯æ–‡ä»¶: $file"
            if [ -f "$file" ]; then
              set +e
              python build/validate.py "$file" --fix 2>&1 | tee -a validation_output.log
              PY_EXIT=$?
              set -e
              if [ $PY_EXIT -ne 0 ]; then
                VALIDATION_FAILED=true
              fi
            else
              echo "è­¦å‘Š: æ–‡ä»¶ä¸å­˜åœ¨ - $file"
            fi
          done < temp_file_list.txt
          rm temp_file_list.txt
          
          # æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶è¢«ä¿®æ”¹
          if [ -n "$(git status --porcelain)" ]; then
            echo "å‘ç°ä¿®æ”¹ï¼Œæäº¤æ›´æ”¹"
            git add .
            git commit -m "è‡ªåŠ¨ä¿®å¤ JSON æ ¼å¼å’Œç‰ˆæœ¬å· [ci skip]"
            
            # ç¡®å®šå½“å‰åˆ†æ”¯
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            echo "å½“å‰åˆ†æ”¯: ${CURRENT_BRANCH}"
            
            if [ "$CURRENT_BRANCH" = "HEAD" ]; then
              # å¦‚æœåœ¨detached HEADçŠ¶æ€ï¼Œä½¿ç”¨æ­£ç¡®çš„æ–¹å¼æ¨é€
              if [ -n "${HEAD_REF}" ]; then
                echo "åœ¨detached HEADçŠ¶æ€ï¼Œä½¿ç”¨HEAD_REFæ¨é€: ${HEAD_REF}"
                git push origin HEAD:${HEAD_REF}
              else
                echo "æ— æ³•ç¡®å®šç›®æ ‡åˆ†æ”¯ï¼Œè·³è¿‡æ¨é€"
              fi
            else
              # å¸¸è§„æ¨é€
              echo "æ¨é€åˆ°åˆ†æ”¯: ${CURRENT_BRANCH}"
              git push origin ${CURRENT_BRANCH}
            fi
          else
            echo "æ²¡æœ‰æ–‡ä»¶è¢«ä¿®æ”¹ï¼Œæ— éœ€æäº¤"
          fi

          # åŸºäºæ—¥å¿—å†…å®¹äºŒæ¬¡åˆ¤å®šå¤±è´¥ï¼ˆvalidate.py è‹¥æœªæ­£ç¡®è¿”å›éé›¶æ—¶ï¼‰
          if grep -E "âŒ|JSON æ ¼å¼é”™è¯¯|JSONæ ¼å¼é”™è¯¯|Expecting property name enclosed in double quotes|Traceback|Error:" -q validation_output.log; then
            VALIDATION_FAILED=true
          fi

          if [ "$VALIDATION_FAILED" = true ]; then
            echo "æ£€æµ‹åˆ°æ ¡éªŒé”™è¯¯ï¼Œç”Ÿæˆæ ¡éªŒè¯´æ˜å¹¶æ ‡è®°å¤±è´¥"
            {
              echo "### âŒ æ ¡éªŒå¤±è´¥"
              echo "è¯·å‰å¾€ Actions æŸ¥çœ‹æŠ¥é”™è¯¦æƒ…ï¼ˆè¿è¡Œæ—¥å¿—ï¼‰ã€‚"
            } > validation_notes.md
            exit 1
          fi

      - name: Run validation for manual trigger
        if: ${{ steps.set_env.outputs.trigger_type == 'manual' }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PR_NUMBER: ${{ steps.set_env.outputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_REF: ${{ steps.pr_info.outputs.head_ref || '' }}
          PR_REPO: ${{ steps.pr_info.outputs.head_repo || github.repository }}
          VALIDATE_PATH: ${{ steps.set_env.outputs.validate_path }}
          AUTO_FIX: ${{ steps.set_env.outputs.auto_fix }}
        run: |
          set -e
          echo "æ‰‹åŠ¨è§¦å‘æ¨¡å¼ï¼ŒéªŒè¯è·¯å¾„: ${VALIDATE_PATH}"
          # ä½¿ç”¨å¼•å·åŒ…è£¹è·¯å¾„ï¼Œå¤„ç†ç‰¹æ®Šå­—ç¬¦
          : > validation_output.log
          set +e
          python build/validate.py "${VALIDATE_PATH}" $([[ "${AUTO_FIX}" == "true" ]] && echo "--fix") 2>&1 | tee -a validation_output.log
          PY_EXIT=$?
          set -e
          VALIDATION_FAILED=false
          if [ $PY_EXIT -ne 0 ]; then
            VALIDATION_FAILED=true
          fi
          if grep -E "âŒ|JSON æ ¼å¼é”™è¯¯|JSONæ ¼å¼é”™è¯¯|Expecting property name enclosed in double quotes|Traceback|Error:" -q validation_output.log; then
            VALIDATION_FAILED=true
          fi
          if [ "$VALIDATION_FAILED" = true ]; then
            {
              echo "### âŒ æ ¡éªŒå¤±è´¥"
              echo "è¯·å‰å¾€ Actions æŸ¥çœ‹æŠ¥é”™è¯¦æƒ…ï¼ˆè¿è¡Œæ—¥å¿—ï¼‰ã€‚"
            } > validation_notes.md
          fi
          
          # æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶è¢«ä¿®æ”¹
          if [ -n "$(git status --porcelain)" ]; then
            echo "å‘ç°ä¿®æ”¹ï¼Œæäº¤æ›´æ”¹"
            git add .
            git commit -m "è‡ªåŠ¨ä¿®å¤ JSON æ ¼å¼å’Œç‰ˆæœ¬å· [ci skip]"
            
            # å¦‚æœå…³è”äº†PRï¼Œå°è¯•æäº¤æ›´æ”¹åˆ°PR
            if [ -n "$PR_NUMBER" ] && [ -n "$HEAD_REF" ]; then
              echo "æäº¤æ›´æ”¹åˆ°PR: #$PR_NUMBER"
              
              # ç¡®å®šå½“å‰åˆ†æ”¯
              CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
              echo "å½“å‰åˆ†æ”¯: ${CURRENT_BRANCH}"
              
              if [ "$CURRENT_BRANCH" = "HEAD" ]; then
                # å¦‚æœåœ¨detached HEADçŠ¶æ€ï¼Œä½¿ç”¨æ­£ç¡®çš„æ–¹å¼æ¨é€
                echo "åœ¨detached HEADçŠ¶æ€ï¼Œä½¿ç”¨HEAD_REFæ¨é€: ${HEAD_REF}"
                git push origin HEAD:${HEAD_REF}
              else
                # å¸¸è§„æ¨é€
                echo "æ¨é€åˆ°åˆ†æ”¯: ${CURRENT_BRANCH}"
                git push origin ${CURRENT_BRANCH}
              fi
            else
              # æœªå…³è”PRæˆ–æ— æ³•ç¡®å®šåˆ†æ”¯ï¼Œç›´æ¥æäº¤åˆ°mainåˆ†æ”¯
              echo "æœªå…³è”PRæˆ–æ— æ³•ç¡®å®šåˆ†æ”¯ï¼Œç›´æ¥æäº¤åˆ°mainåˆ†æ”¯"
              
              # ä¿å­˜ä¿®æ”¹çš„æ–‡ä»¶åˆ—è¡¨
              MODIFIED_FILES=$(git status --porcelain | grep -E "^ M|^M" | awk '{print $2}')
              echo "å·²ä¿®æ”¹çš„æ–‡ä»¶:"
              echo "$MODIFIED_FILES"
              
              # å°†ä¿®æ”¹çš„æ–‡ä»¶ä¿å­˜åˆ°ä¸´æ—¶ç›®å½•
              TEMP_DIR=$(mktemp -d)
              echo "åˆ›å»ºä¸´æ—¶ç›®å½•: $TEMP_DIR"
              for file in $MODIFIED_FILES; do
                # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
                mkdir -p "$TEMP_DIR/$(dirname "$file")"
                # å¤åˆ¶ä¿®æ”¹åçš„æ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•
                cp "$file" "$TEMP_DIR/$file"
                echo "å·²å¤åˆ¶æ–‡ä»¶: $file"
              done
              
              # åˆ‡æ¢åˆ°mainåˆ†æ”¯
              git fetch upstream main
              git checkout -b temp-main upstream/main
              
              # ä»ä¸´æ—¶ç›®å½•å¤åˆ¶ä¿®æ”¹åçš„æ–‡ä»¶åˆ°mainåˆ†æ”¯
              for file in $MODIFIED_FILES; do
                # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
                mkdir -p "$(dirname "$file")"
                # å¤åˆ¶æ–‡ä»¶
                cp "$TEMP_DIR/$file" "$file"
                echo "å·²åº”ç”¨ä¿®æ”¹åˆ°mainåˆ†æ”¯: $file"
              done
              
              # æäº¤å¹¶æ¨é€
              git add .
              git commit -m "è‡ªåŠ¨ä¿®å¤ JSON æ ¼å¼å’Œç‰ˆæœ¬å· [ci skip]"
              git push upstream temp-main:main
            fi
          else
            echo "æ²¡æœ‰æ–‡ä»¶è¢«ä¿®æ”¹ï¼Œæ— éœ€æäº¤"
          fi
          
          if [ "$VALIDATION_FAILED" = true ]; then
            exit 1
          fi
          
      - name: Add PR comment
        if: ${{ always() && ((steps.set_env.outputs.trigger_type == 'pr') || (steps.set_env.outputs.trigger_type == 'manual' && steps.set_env.outputs.pr_number != '' && steps.pr_info.outputs.found == 'true')) }}
        continue-on-error: true
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const pr_number = ${{ steps.set_env.outputs.pr_number }};
            
            if (fs.existsSync('validation_notes.md')) {
              const message = fs.readFileSync('validation_notes.md', 'utf8');
              await github.rest.issues.createComment({
                issue_number: pr_number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: message
              });
            } else {
              console.log("æ²¡æœ‰å‘ç° validation_notes.md æ–‡ä»¶");
              
              // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶è¢«ä¿®æ”¹å¹¶æäº¤
              const { execSync } = require('child_process');
              let commitMessage = '';
              
              try {
                const lastCommit = execSync('git log -1 --pretty=%B').toString().trim();
                if (lastCommit.includes('è‡ªåŠ¨ä¿®å¤')) {
                  commitMessage = 'âœ… æ ¡éªŒå®Œæˆå¹¶è‡ªåŠ¨ä¿®å¤äº†ä¸€äº›é—®é¢˜ã€‚ä¿®æ”¹å·²æäº¤åˆ°PRä¸­ã€‚';
                } else {
                  commitMessage = 'âœ… æ ¡éªŒå®Œæˆï¼Œæ²¡æœ‰å‘ç°éœ€è¦ä¿®å¤çš„é—®é¢˜';
                }
              } catch (error) {
                commitMessage = 'âœ… æ ¡éªŒå®Œæˆï¼Œæ²¡æœ‰å‘ç°éœ€è¦ä¿®å¤çš„é—®é¢˜';
              }
              
              await github.rest.issues.createComment({
                issue_number: pr_number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commitMessage
              });
            }
