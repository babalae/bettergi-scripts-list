name: JSON Data Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches:
      - main
    # ä¿®æ”¹è·¯å¾„åŒ¹é…ï¼Œä½¿å…¶æ›´å®½æ¾
    paths:
      - '**/*.json'

jobs:
  validate-json:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.head_ref }}
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      run: |
        pip install packaging semver

    - name: Run validation and correction
      env:
        GITHUB_ACTOR: ${{ github.actor }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        HEAD_REF: ${{ github.head_ref }}
      run: |
        cat << 'EOF' > validate.py
        import json
        import os
        import sys
        import subprocess
        from packaging.version import parse
        from semver import VersionInfo

        # å®šä¹‰æœ‰æ•ˆçš„ type å’Œ move_mode å€¼
        VALID_TYPES = ["teleport", "path", "target", "orientation"]
        VALID_MOVE_MODES = ["walk", "fly", "climb", "run", "dash", "jump"]
        
        # å®šä¹‰ action å’Œ action_params çš„æœ€ä½å…¼å®¹ç‰ˆæœ¬
        ACTION_VERSION_MAP = {
            "stop_flying": "0.42.0",
            "force_tp": "0.42.0",
            "nahida_collect": "0.42.0",
            "pick_around": "0.42.0",
            "hydro_collect": "0.42.0",
            "electro_collect": "0.42.0",
            "anemo_collect": "0.42.0",
            "pyro_collect": "0.43.0",
            "up_down_grab_leaf": "0.42.0",
            "fight": "0.42.0",
            "combat_script": "0.42.0",
            "log_output": "0.42.0",
            "fishing": "0.43.0"
        }
        
        # å®šä¹‰ action_params çš„æœ€ä½å…¼å®¹ç‰ˆæœ¬å’Œæ­£åˆ™è¡¨è¾¾å¼éªŒè¯
        ACTION_PARAMS_VERSION_MAP = {            
            "stop_flying": {
                "params": {"version": "0.44.0", "regex": r"^\d+(\.\d+)?$"}
            },
            "pick_around": {
                "params": {"version": "0.42.0", "regex": r"^\d+$"}
            },
            "combat_script": {
                "params": {"version": "0.36.4", "regex": r"^.+$"}  # ä»»æ„éç©ºå­—ç¬¦ä¸²
            },
            "log_output": {
                "params": {"version": "0.40.0", "regex": r"^.+$"}  # ä»»æ„éç©ºå­—ç¬¦ä¸²
            }
            # å…¶ä»– action ç±»å‹æ²¡æœ‰æ˜ç¡®çš„ action_params æ ¼å¼è¦æ±‚
        }

        def get_original_file(file_path):
            try:
                result = subprocess.run(['git', 'show', f'origin/main:{file_path}'], 
                                      capture_output=True, text=True)
                return json.loads(result.stdout) if result.returncode == 0 else None
            except Exception as e:
                print(f"è·å–åŸå§‹æ–‡ä»¶å¤±è´¥: {str(e)}")
                return None

        def process_version(current, original, is_new):
            if is_new:
                return "1.0"
            try:
                # ä¿®æ”¹ç‰ˆæœ¬å·å¤„ç†é€»è¾‘ï¼Œç¡®ä¿æ€»æ˜¯å¢åŠ ç‰ˆæœ¬å·
                if not original:
                    return "1.0"
                
                try:
                    cv = parse(current)
                    ov = parse(original)
                    # å¼ºåˆ¶æ›´æ–°ç‰ˆæœ¬å·ï¼Œæ— è®ºå½“å‰ç‰ˆæœ¬æ˜¯å¦å¤§äºåŸå§‹ç‰ˆæœ¬
                    return f"{ov.major}.{ov.minor + 1}"
                except:
                    # å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•ç®€å•çš„æ•°å­—å¤„ç†
                    parts = original.split('.')
                    if len(parts) >= 2:
                        try:
                            major = int(parts[0])
                            minor = int(parts[1])
                            return f"{major}.{minor + 1}"
                        except:
                            pass
                    return f"{original}.1"
            except Exception as e:
                print(f"å¤„ç†ç‰ˆæœ¬å·å¤±è´¥: {str(e)}")
                return "1.0" if not original else f"{original}.1"
        
        def check_action_compatibility(action_type, action_params, bgi_version):
            """æ£€æŸ¥ action å’Œ action_params ä¸ BGI ç‰ˆæœ¬çš„å…¼å®¹æ€§"""
            import re
            issues = []
            validation_issues = []
            
            # å¦‚æœ action_type ä¸ºç©ºï¼Œåˆ™è·³è¿‡æ£€æŸ¥
            if not action_type:
                return issues, validation_issues
            
            # æ£€æŸ¥ action å…¼å®¹æ€§
            if action_type in ACTION_VERSION_MAP:
                min_version = ACTION_VERSION_MAP[action_type]
                if VersionInfo.parse(bgi_version.lstrip('v')) < VersionInfo.parse(min_version):
                    issues.append(f"action '{action_type}' éœ€è¦ BGI ç‰ˆæœ¬ >= {min_version}ï¼Œå½“å‰ä¸º {bgi_version}")
            else:
                # æœªçŸ¥çš„ action ç±»å‹
                validation_issues.append(f"æœªçŸ¥çš„ action ç±»å‹: '{action_type}'ï¼Œå·²çŸ¥ç±»å‹: {', '.join(sorted(ACTION_VERSION_MAP.keys()))}")
            
            # æ£€æŸ¥ action_params å…¼å®¹æ€§å’Œæ ¼å¼
            if action_type in ACTION_PARAMS_VERSION_MAP and action_params:
                param_info = ACTION_PARAMS_VERSION_MAP[action_type]["params"]
                min_version = param_info["version"]
                regex_pattern = param_info["regex"]
                
                # ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
                if VersionInfo.parse(bgi_version.lstrip('v')) < VersionInfo.parse(min_version):
                    issues.append(f"action '{action_type}' çš„å‚æ•°éœ€è¦ BGI ç‰ˆæœ¬ >= {min_version}ï¼Œå½“å‰ä¸º {bgi_version}")
                
                # å‚æ•°æ ¼å¼éªŒè¯
                if not re.match(regex_pattern, str(action_params)):
                    validation_issues.append(f"action '{action_type}' çš„å‚æ•°æ ¼å¼ä¸æ­£ç¡®: '{action_params}'ï¼Œåº”åŒ¹é…æ¨¡å¼: {regex_pattern}")
            
            return issues, validation_issues
        
        def validate_file(file_path):
            try:
                with open(file_path) as f:
                    data = json.load(f)
            except Exception as e:
                print(f"âŒ JSON æ ¼å¼é”™è¯¯: {str(e)}")
                sys.exit(1)

            original_data = get_original_file(file_path)
            is_new = not original_data
            info = data["info"]
            filename = os.path.splitext(os.path.basename(file_path))[0]

            # è‡ªåŠ¨ä¿®æ­£é€»è¾‘
            corrections = []
            if info["name"] != filename:
                info["name"] = filename
                corrections.append(f"name è‡ªåŠ¨ä¿®æ­£ä¸º {filename}")
            
            if info["type"] not in ["collect", "fight"]:
                info["type"] = "collect"
                corrections.append("type è‡ªåŠ¨ä¿®æ­£ä¸º collect")
            
            if not info["author"]:
                info["author"] = os.getenv("GITHUB_ACTOR")
                corrections.append(f"author è‡ªåŠ¨è®¾ç½®ä¸º {info['author']}")
            
            # å¤„ç†åæ ‡ä¿ç•™ä¸¤ä½å°æ•°
            coord_changed = False
            for pos in data["positions"]:
                if "x" in pos and isinstance(pos["x"], (int, float)):
                    original_x = pos["x"]
                    pos["x"] = round(float(pos["x"]), 2)
                    if original_x != pos["x"]:
                        coord_changed = True
                
                if "y" in pos and isinstance(pos["y"], (int, float)):
                    original_y = pos["y"]
                    pos["y"] = round(float(pos["y"]), 2)
                    if original_y != pos["y"]:
                        coord_changed = True
            
            if coord_changed:
                corrections.append("åæ ‡å€¼è‡ªåŠ¨ä¿ç•™ä¸¤ä½å°æ•°")
            
            # æ£€æŸ¥ action å’Œ action_params å…¼å®¹æ€§
            bgi_version = info["bgiVersion"]
            compatibility_issues = []
            validation_issues = []
            
            for idx, pos in enumerate(data["positions"]):
                # éªŒè¯ type å­—æ®µ
                if "type" in pos:
                    pos_type = pos["type"]
                    if pos_type not in VALID_TYPES:
                        validation_issues.append(f"ä½ç½® {idx+1}: type '{pos_type}' æ— æ•ˆï¼Œæœ‰æ•ˆå€¼ä¸º: {', '.join(VALID_TYPES)}")
                    
                    # å½“ type ä¸º path æˆ– target æ—¶ï¼ŒéªŒè¯ move_mode
                    if pos_type in ["path", "target"]:
                        if "move_mode" not in pos:
                            validation_issues.append(f"ä½ç½® {idx+1}: type ä¸º '{pos_type}' æ—¶å¿…é¡»æŒ‡å®š move_mode")
                        elif pos["move_mode"] not in VALID_MOVE_MODES:
                            validation_issues.append(f"ä½ç½® {idx+1}: move_mode '{pos['move_mode']}' æ— æ•ˆï¼Œæœ‰æ•ˆå€¼ä¸º: {', '.join(VALID_MOVE_MODES)}")
                
                # éªŒè¯ action å…¼å®¹æ€§
                action_type = pos.get("action", "")
                action_params = pos.get("params", "")
                
                if action_type:
                    compat_issues, valid_issues = check_action_compatibility(action_type, action_params, bgi_version)
                    
                    for issue in compat_issues:
                        compatibility_issues.append(f"ä½ç½® {idx+1}: {issue}")
                    
                    for issue in valid_issues:
                        validation_issues.append(f"ä½ç½® {idx+1}: {issue}")
            
            # æ ¹æ®å…¼å®¹æ€§é—®é¢˜æ›´æ–° bgiVersion
            if compatibility_issues:
                required_versions = []
                for issue in compatibility_issues:
                    # ä»é”™è¯¯ä¿¡æ¯ä¸­æå–ç‰ˆæœ¬å·
                    parts = issue.split(">=")
                    if len(parts) > 1:
                        version_part = parts[1].split(",")[0].strip()
                        required_versions.append(version_part)
                
                if required_versions:
                    max_required = max(required_versions, key=lambda v: VersionInfo.parse(v))
                    current_bgi = VersionInfo.parse(bgi_version.lstrip('v'))
                    if current_bgi < VersionInfo.parse(max_required):
                        info["bgiVersion"] = f"v{max_required}"
                        corrections.append(f"bgiVersion è‡ªåŠ¨æ›´æ–°ä¸º v{max_required} ä»¥å…¼å®¹æ‰€æœ‰åŠŸèƒ½")
                        compatibility_issues = []  # æ¸…ç©ºå…¼å®¹æ€§é—®é¢˜ï¼Œå› ä¸ºå·²ç»æ›´æ–°äº†ç‰ˆæœ¬
            
            original_version = original_data["info"]["version"] if original_data and "info" in original_data else None
            print(f"åŸå§‹ç‰ˆæœ¬å·: {original_version}, å½“å‰ç‰ˆæœ¬å·: {info['version']}, æ˜¯å¦æ–°æ–‡ä»¶: {is_new}")
            
            new_version = process_version(info["version"], original_version, is_new)
            if new_version != info["version"]:
                info["version"] = new_version
                corrections.append(f"version è‡ªåŠ¨æ›´æ–°ä¸º {new_version}")
                print(f"ç‰ˆæœ¬å·å·²æ›´æ–°: {info['version']}")
            else:
                print(f"ç‰ˆæœ¬å·æœªå˜åŒ–: {info['version']}")
            
            try:
                bgi_ver = VersionInfo.parse(info["bgiVersion"].lstrip('v'))
                if not (bgi_ver > VersionInfo.parse("0.42.0")):
                    print(f"âŒ bgiVersion {info['bgiVersion']} å¿…é¡»å¤§äº 0.42")
                    sys.exit(1)
            except ValueError:
                print(f"âŒ æ— æ•ˆçš„ bgiVersion æ ¼å¼: {info['bgiVersion']}")
                sys.exit(1)

            # æ ¡éªŒ positions
            notices = []
            for idx, pos in enumerate(data["positions"]):
                if not all(key in pos for key in ["x", "y", "type"]):
                    print(f"âŒ position {idx+1} ç¼ºå°‘å¿…éœ€å­—æ®µ")
                    sys.exit(1)
                if idx == 0 and pos["type"] != "teleport":
                    notices.append("âš ï¸ ç¬¬ä¸€ä¸ª position çš„ type ä¸æ˜¯ teleport")
            
            # æ·»åŠ å…¼å®¹æ€§é—®é¢˜å’ŒéªŒè¯é—®é¢˜åˆ°é€šçŸ¥ä¸­
            for issue in compatibility_issues:
                notices.append(issue)
                
            # æ·»åŠ éªŒè¯é—®é¢˜åˆ°é€šçŸ¥ä¸­
            for issue in validation_issues:
                notices.append(issue)

            # ä¿å­˜ä¿®æ­£
            if corrections:
                with open(file_path, 'w') as f:
                    json.dump(data, f, indent=2, ensure_ascii=False)
                subprocess.run(['git', 'add', file_path])
                print("ğŸ”§ è‡ªåŠ¨ä¿®æ­£:", ", ".join(corrections))

            return notices

        # ä¸»æµç¨‹
        changed_files = subprocess.run(['git', 'diff', '--name-only', 'origin/main...HEAD'], 
                                     capture_output=True, text=True).stdout.splitlines()
        
        print(f"æ£€æµ‹åˆ°çš„å˜æ›´æ–‡ä»¶: {changed_files}")
        
        all_notices = []
        for f in [f for f in changed_files if f.endswith('.json')]:
            print(f"\nğŸ” æ ¡éªŒæ–‡ä»¶: {f}")
            notices = validate_file(f)
            all_notices.extend([f"{f}: {n}" for n in notices])

        # æäº¤è‡ªåŠ¨ä¿®æ­£
        if subprocess.run(['git', 'diff', '--staged', '--quiet']).returncode:
            print("æ£€æµ‹åˆ°éœ€è¦æäº¤çš„ä¿®æ”¹")
            subprocess.run(['git', 'config', 'user.name', 'GitHub Actions'])
            subprocess.run(['git', 'config', 'user.email', 'actions@github.com'])
            commit_result = subprocess.run(['git', 'commit', '-m', 'ğŸ›  è‡ªåŠ¨æ ¡éªŒä¿®æ­£'], capture_output=True, text=True)
            print(f"æäº¤ç»“æœ: {commit_result.stdout} {commit_result.stderr}")
            
            # ä¿®æ”¹ push å‘½ä»¤ï¼ŒæŒ‡å®šè¿œç¨‹åˆ†æ”¯åç§°
            head_ref = os.getenv('HEAD_REF')
            if not head_ref:
                print("âš ï¸ æ— æ³•è·å– HEAD_REF ç¯å¢ƒå˜é‡")
                head_ref = "HEAD:refs/heads/" + subprocess.run(['git', 'rev-parse', '--abbrev-ref', 'HEAD'], 
                                                            capture_output=True, text=True).stdout.strip()
                print(f"ä½¿ç”¨å½“å‰åˆ†æ”¯: {head_ref}")
            
            push_result = subprocess.run(['git', 'push', 'origin', f'HEAD:{head_ref}'], capture_output=True, text=True)
            print(f"æ¨é€ç»“æœ: {push_result.stdout} {push_result.stderr}")
            
            if push_result.returncode == 0:
                print("âœ… è‡ªåŠ¨ä¿®æ­£å·²æäº¤")
            else:
                print(f"âŒ æ¨é€å¤±è´¥: {push_result.stderr}")
        else:
            print("æ²¡æœ‰éœ€è¦æäº¤çš„ä¿®æ”¹")

        # ç”Ÿæˆæé†’ä¿¡æ¯
        if all_notices:
            with open('validation_notes.md', 'w') as f:
                f.write("## æ ¡éªŒæ³¨æ„äº‹é¡¹\n\n" + "\n".join(f"- {n}" for n in all_notices))
        EOF

        python validate.py

    - name: Add PR comment
      if: always()
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          if (fs.existsSync('validation_notes.md')) {
            const message = fs.readFileSync('validation_notes.md', 'utf8');
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });
          } else {
            console.log("æ²¡æœ‰å‘ç° validation_notes.md æ–‡ä»¶");
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "âœ… æ ¡éªŒå®Œæˆï¼Œæ²¡æœ‰å‘ç°é—®é¢˜"
            });
          }
